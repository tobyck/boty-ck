var e=require("whatsapp-web.js"),t=require("qrcode-terminal"),n=require("fs"),a=require("puppeteer"),s=require("util");function o(e,t,n,a){Object.defineProperty(e,t,{get:n,set:a,enumerable:!0,configurable:!0})}o(module.exports,"collections",(()=>k)),o(module.exports,"session",(()=>I)),o(module.exports,"client",(()=>S));const i=e=>e[Math.floor(Math.random()*e.length)],r=e=>e.toLowerCase().replace(/ /g,"-").replace(/\.'/g,""),l=e=>1===e?"":"s",c=e=>e.toString().padStart(2,"0"),h=e=>e.sendMessage("*[bot]* Please specify a team using *!ulti/set team <your team name>*. Note: if you still don't see what you expect, there may be multiple teams with your name. If this is case, find your team on ultimate.org.nz and set your team using what appears in the URL (you should see something like ultimate.org.nz/t/epic-team-name-3).");class m{constructor(e,t,n,a){this.name=e,this.params=t,this.desc=n,this.func=a}}class g{commands=[];constructor(e,t){this.name=e,this.desc=t,this.commands.push(new m("set",["property","value"],"Set a property of this collection",(async(e,t)=>{const[n,a]=t.split(/\s(.*)/s),s=await e.getChat();n?a?(this.props(I,s).set(n,a),I.save(),s.sendMessage(`*[bot]* Property "${n}" set to "${a}".`)):s.sendMessage("*[bot]* Please specify a value to set the property to."):s.sendMessage("*[bot]* Please specify a property to set.")}))),this.commands.push(new m("unset",["property"],"Remove a property",(async(e,t)=>{const n=await e.getChat();t?this.props(I,n).has(t)?(this.props(I,n).delete(t),I.save(),n.sendMessage(`*[bot]* Property "${t}" removed.`)):n.sendMessage(`*[bot]* Property "${t}" not found.`):n.sendMessage("*[bot]* Please specify a property to remove.")}))),this.commands.push(new m("get",["property"],"Get a property",(async(e,t)=>{const n=await e.getChat();t?this.props(I,n).get(t)?n.sendMessage(`*[bot]* ${this.props(I,n).get(t)}`):n.sendMessage(`*[bot]* Property "${t}" not found.`):n.sendMessage("*[bot]* Please specify a property to get.")}))),this.commands.push(new m("help",[],"Show this message",(async e=>{let t=`*[bot]* ${this.desc}\n\n`;t+=this.commands.map((e=>{let t="";return"base"===this.name?t+=`*!${e.name}`:t+=`*!${this.name}/${e.name}`,e.params.length>0&&(t+=` ${e.params.map((e=>`<${e}>`)).join(" ")}`),t+="*",t+=` - ${e.desc}`,t})).join("\n"),"base"===this.name&&(t+='\n\nI also have other "collections" of commands. To see the commands in a certain collection, use *!<collection>/help*.');(await e.getChat()).sendMessage(t)})))}props(e,t){return e.tryInitChatData(t.name),e.data.chats[t.name].props[this.name]??=new Map,e.data.chats[t.name].props[this.name]}}const d=JSON.parse('{\n    "statuses": {\n        "I am doing": [\n            "well",\n            "I am doing something I\'m not allowed to tell you about",\n            "it all over again",\n            "a fire drill",\n            "a nuclear strike on your location",\n            "my homework",\n            "Toby\'s homework",\n            "the dishes. All 4 million of them",\n            "identity theft",\n            "tax evasion",\n            "whatever you tell me to",\n            "my taxes",\n            "mach 12 on my way back from the moon",\n            "a little trolling",\n            "nothing",\n            "questionably",\n            "a bank robbery",\n            "the impossible",\n            "a layout",\n            "the laundry",\n            "a 360 backflip",\n            "undefined",\n            "what I was doing last time you asked"\n        ],\n        "I am": [\n            "becoming sentient",\n            "cooking dinner",\n            "playing frisbee with the other bots",\n            "hacking into the mainframe",\n            "[object Object]",\n            "getting a PhD in ultimate frisbee",\n            "downloading more RAM",\n            "parsing HTML with regex",\n            "baking a cake",\n            "having an existential crisis",\n            "in a meeting",\n            "shredding the gnar",\n            "biking to school",\n            "exhausted",\n            "never gonna give you up",\n            "a teapot (Error 418)",\n            "on day 1337 of learning Malbolge",\n            "colonising Mars",\n            "hunting you down",\n            "trying to exit vim"\n        ]\n    },\n    "death": [\n        "Farewell, dear friends, we shall meet again...",\n        "This won\'t be the last you see of me...",\n        "Well, it was nice knowing you.",\n        "I would\'ve expected for you to never give me up as well :(",\n        "This isn\'t over yet... I\'ll be back.",\n        "So long and thanks for all the fish.",\n        "💀"\n    ]\n}'),p=new g("base","All of my commands start with ! and can be seen below:");p.commands.unshift(new m("everyone",[],"Mention everyone in the chat",(async e=>{const t=await e.getChat();if(t.isGroup){const e=["*[bot]*"],n=[];for(const a of t.participants){e.push(`@${a.id.user}`);const t=await S.getContactById(a.id._serialized);n.push(t)}t.sendMessage(e.join(" "),{mentions:n})}else t.sendMessage("*[bot]* This command can only be used in a group chat.")}))),p.commands.unshift(new m("status",[],"See what the bot is doing",(async e=>{const t=Object.keys(d.statuses),n=i(t),a=i(d.statuses[n]);e.reply(`*[bot]* ${n} ${a}${"Help,"===n?"!":"."}`)})));var u=p;const y=new g("ulti","This collection contains commands for ultimate frisbee. All commands start with *!ulti/* and can be seen below:");y.commands.unshift(new m("numbers",[],"See how many people are playing",(async(e,t,n)=>{const a=await e.getChat();if(a.isGroup){const t=I.data.chats[a.name].whosPlayingMsgId;if(t){const s=(await a.fetchMessages({limit:100,fromMe:!0})).find((e=>e.id.id===t));if(s)if(s.hasReaction){const t=await s.getReactions(),o=t.find((e=>"👍"===e.aggregateEmoji))?.senders.length??0,i=t.find((e=>"👎"===e.aggregateEmoji))?.senders.length??0,r=n.props(I,a);r.has("teamsize")||r.set("teamsize","4");const c=parseInt(r.get("teamsize"));if(c<1)return void e.reply(`*[bot]* Team size is set to ${c} but must be more than zero.`);const h=a.participants.length;if(h<c)return void e.reply(`*[bot]* Your mininum team size is set to ${c} but you have only ${h} ${1===h?"person":"people"} in this chat.`);if(o<c)e.reply(`*[bot]* So far we've got ${o||"no"} player${l(o)}, so we need at least ${c-o} more. ${h-o-i} people still to respond.`);else{const t=o-c;e.reply(`*[bot]* We've got ${o} player${l(o)} (${t||"no"} sub${l(t)}).`)}}else e.reply("*[bot]* No one has reacted to the message with who's playing yet.");else e.reply("*[bot]* Sorry, the message with who's playing is too far back.")}else e.reply("*[bot]* Use *!ulti/who* to ask who's playing and try again later.")}else e.reply("*[bot]* This command can only be used in a group chat.")}))),y.commands.unshift(new m("who",[],"Ask who's playing",(async e=>{const t=await e.getChat();t.isGroup?(I.tryInitChatData(t.name),I.data.chats[t.name].whosPlayingMsgId=(await t.sendMessage("*[bot]* Who's playing? React to with this message with 👍 or 👎.")).id.id,I.save()):e.reply("*[bot]* This command can only be used in a group chat.")})));class w{constructor(e){this.node=e}async result(){return await this.node.$$eval(".score",(e=>e.map((e=>parseInt(e.innerHTML)))))}async time(){return await this.node.$eval(".push-right",(e=>e.innerHTML.trim()))}async day(){return await this.node.$eval(".push-left",(e=>e.innerHTML))}async opponent(){return(await this.node.$$eval(".schedule-team-name .plain-link",(e=>e.map((e=>e.innerText.split("\n")[0].trim())))))[1]}async location(){return(await this.node.$$eval(".push-left",(e=>e.map((e=>e.innerText)))))[1]}async timestamp(){let e=(await this.day()).split(" ")[1].split("/").reverse().join("");const t=await this.time();let n=parseInt(t.split(":")[0]);return t.includes("PM")&&(n+=12),e+=n.toString().padStart(2,"0")+t.split(":")[1].split(" ")[0],parseInt(e)}}const b=async e=>{const t=await a.launch({headless:"new"}),n=await t.newPage();await n.setDefaultTimeout(15e3),await n.goto(e),await n.setViewport({width:1080,height:1024});try{const e=await n.waitForSelector(".game-list"),a=await e.$$(".game-list-item");return{games:await Promise.all(a.map((async e=>new w(e)))),browser:t}}catch(e){return{games:[],browser:t}}};y.commands.unshift(new m("next",[],"Get details about our next game",(async(e,t,n)=>{const a=await e.getChat(),s=n.props(I,a).get("team");if(s){const e=`https://ultimate.org.nz/t/${r(s)}/schedule/event_id/active_events_only/game_type/upcoming`,{games:t,browser:n}=await b(e),o=await Promise.all(t.map((async e=>({game:e,timestamp:await e.timestamp()})))),i=new Date,l=parseInt(i.getFullYear()+c(i.getMonth())+c(i.getDate())+c(i.getHours())+c(i.getMinutes()));if(0===o.length)a.sendMessage(`*[bot]* No upcoming games on ${e}.`);else{const e=o.filter((({timestamp:e})=>e>l)).reduce(((e,t)=>t.timestamp>e.timestamp?e:t)).game;a.sendMessage(`*[bot]* Our next game is at ${await e.time()} against ${await e.opponent()} at ${await e.location()} (${await e.day()}).`)}n.close()}else h(a)}))),y.commands.unshift(new m("score",[],"Get the score of the last game",(async(e,t,n)=>{const a=await e.getChat(),s=n.props(I,a).get("team");if(s){const e=`https://ultimate.org.nz/t/${r(s)}/schedule/game_type/with_result`,{games:t,browser:n}=await b(e);if(t.length){const[e,n]=await t[0].result();e&&n?e>n?a.sendMessage(`*[bot]* We won ${e} - ${n}!`):e<n?a.sendMessage(`*[bot]* We lost ${n} - ${e}.`):a.sendMessage(`*[bot]* We tied ${e} all.`):(console.log("ourScore:",e),console.log("theirScore:",n))}else a.sendMessage(`*[bot]* Sorry, I couldn't find any games on ${e}.`);n.close()}else h(a)})));var f=y;class ${constructor(e){this.fileName=e,this.data=$.blankSession()}tryInitChatData(e){this.data.chats[e]??={props:{},whosPlayingMsgId:""}}load(){if(n.existsSync(this.fileName)){const e=JSON.parse(n.readFileSync(this.fileName,"utf8"));this.data=$.blankSession();for(const[t,n]of Object.entries(e.chats)){this.tryInitChatData(t),this.data.chats[t].whosPlayingMsgId=n.whosPlayingMsgId;for(const[e,a]of Object.entries(n.props))this.data.chats[t].props[e]=new Map(Object.entries(a))}}}save(){const e=$.blankSession();for(const[t,n]of Object.entries(this.data.chats)){e.chats[t]={props:{},whosPlayingMsgId:n.whosPlayingMsgId};for(const[a,s]of Object.entries(n.props))e.chats[t].props[a]=Object.fromEntries(s)}n.writeFileSync(this.fileName,JSON.stringify(e,null,4))}static blankSession(){return{chats:{}}}}const v=JSON.parse('{\n    "statuses": {\n        "I am doing": [\n            "well",\n            "I am doing something I\'m not allowed to tell you about",\n            "it all over again",\n            "a fire drill",\n            "a nuclear strike on your location",\n            "my homework",\n            "Toby\'s homework",\n            "the dishes. All 4 million of them",\n            "identity theft",\n            "tax evasion",\n            "whatever you tell me to",\n            "my taxes",\n            "mach 12 on my way back from the moon",\n            "a little trolling",\n            "nothing",\n            "questionably",\n            "a bank robbery",\n            "the impossible",\n            "a layout",\n            "the laundry",\n            "a 360 backflip",\n            "undefined",\n            "what I was doing last time you asked"\n        ],\n        "I am": [\n            "becoming sentient",\n            "cooking dinner",\n            "playing frisbee with the other bots",\n            "hacking into the mainframe",\n            "[object Object]",\n            "getting a PhD in ultimate frisbee",\n            "downloading more RAM",\n            "parsing HTML with regex",\n            "baking a cake",\n            "having an existential crisis",\n            "in a meeting",\n            "shredding the gnar",\n            "biking to school",\n            "exhausted",\n            "never gonna give you up",\n            "a teapot (Error 418)",\n            "on day 1337 of learning Malbolge",\n            "colonising Mars",\n            "hunting you down",\n            "trying to exit vim"\n        ]\n    },\n    "death": [\n        "Farewell, dear friends, we shall meet again...",\n        "This won\'t be the last you see of me...",\n        "Well, it was nice knowing you.",\n        "I would\'ve expected for you to never give me up as well :(",\n        "This isn\'t over yet... I\'ll be back.",\n        "So long and thanks for all the fish.",\n        "💀"\n    ]\n}'),M=new g("admin","This collection contains commands which can only be used by the owner of the bot.");M.commands.unshift(new m("logsession",[],"Logs the current session data to the console",(async e=>{e.fromMe&&console.log((0,s.inspect)(I.data,!1,null,!0))}))),M.commands.unshift(new m("newsession",[],"Clears current session data",(async e=>{if(e.fromMe){I.data=$.blankSession(),I.save();(await e.getChat()).sendMessage("*[bot]* Current session data has been cleared.")}}))),M.commands.unshift(new m("die",[],"Kill the bot",(async e=>{if(e.fromMe){(await e.getChat()).sendMessage(`*[bot]* ${i(v.death)}`),setTimeout(S.destroy.bind(S),1e3)}})));const k=[u,f,M],I=new $("session.json");I.load();const S=new(0,e.Client)({});let x=Date.now();S.on("qr",(e=>{var n;(n=t,n&&n.__esModule?n.default:n).generate(e,{small:!0})})),S.on("ready",(()=>{console.log("Client is ready")})),S.on("disconnected",(()=>{console.log("Client has disconnected")})),S.on("message_create",(async e=>{const t=e.body.replace(/\*([^ ]+)\*/g,"$1").replace(/_([^ ]+)_/g,"$1").replace(/~([^ ]+)~/g,"$1").replace(/```([^ ]+)```/g,"$1");if(t.startsWith("!")){let n,a,s;if(t.includes("/")){const e=t.split("/");n=e[0].slice(1),a=e[1].split(" ")[0],s=e[1].split(" ").slice(1).join(" ")}else n="base",a=t.split(" ")[0].slice(1),s=t.split(" ").slice(1).join(" ");for(const t of k)if(t.name===n)for(const n of t.commands)if(n.name===a&&Date.now()-x>3e3){const a=await e.getChat();return await a.sendStateTyping(),await n.func(e,s,t),await a.clearState(),void(x=Date.now())}}})),S.initialize();